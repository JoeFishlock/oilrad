{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"API Reference","text":"<p>Two-stream shortwave radiative transfer model for sea ice containing oil droplets.</p>"},{"location":"#oilrad.infinite_layer","title":"<code>infinite_layer</code>","text":"<p>Solve the two-stream shortwave radiation model.</p> <p>Infinite layer refers to the continuous variation of the optical properties with depth.</p>"},{"location":"#oilrad.infinite_layer.InfiniteLayerModel","title":"<code>InfiniteLayerModel</code>  <code>dataclass</code>","text":"<p>Class containing all the necessary parameters to solve the two-stream shortwave radiative transfer model in a domain with continuously varying liquid fraction and oil mass ratio.</p> <p>If no array is provided for liquid fraction, it is assumed to be zero everywhere. This corresponds to a completely frozen domain.</p> <p>Oil mass ratio is provided in ng oil / g ice and, along with the median droplet radius for the oil droplet distribution, is used to calculate the absorption coefficient by interpolating data for Romashkino oil from Redmond Roche et al. 2022.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>NDArray</code> <p>vertical grid in meters</p> required <code>wavelengths</code> <code>NDArray</code> <p>array of wavelengths in nm</p> required <code>oil_mass_ratio</code> <code>NDArray</code> <p>array of oil mass ratio in ng oil / g ice on the vertical grid</p> required <code>ice_scattering_coefficient</code> <code>float</code> <p>scattering coefficient for ice in 1/m</p> required <code>median_droplet_radius_in_microns</code> <code>float</code> <p>median droplet radius in microns</p> required <code>absorption_enhancement_factor</code> <code>float</code> <p>enhancement factor for oil absorption appropriate for the two-stream model</p> <code>1</code> <code>liquid_fraction</code> <code>NDArray</code> <p>liquid fraction array on the vertical grid</p> <code>None</code> <code>fast_solve</code> <code>Bool</code> <p>if True, solve the model only for wavelengths below a wavelength cutoff, assume longer wavelengths are absorbed at the surface</p> <code>False</code> <code>wavelength_cutoff</code> <code>float</code> <p>cutoff wavelength in nm</p> <code>None</code> Source code in <code>oilrad/infinite_layer.py</code> <pre><code>@dataclass\nclass InfiniteLayerModel:\n    \"\"\"Class containing all the necessary parameters to solve the two-stream shortwave\n    radiative transfer model in a domain with continuously varying liquid fraction and\n    oil mass ratio.\n\n    If no array is provided for liquid fraction, it is assumed to be zero everywhere.\n    This corresponds to a completely frozen domain.\n\n    Oil mass ratio is provided in ng oil / g ice and, along with the median droplet radius\n    for the oil droplet distribution, is used to calculate the absorption coefficient\n    by interpolating data for Romashkino oil from Redmond Roche et al. 2022.\n\n    Args:\n        z (NDArray): vertical grid in meters\n        wavelengths (NDArray): array of wavelengths in nm\n        oil_mass_ratio (NDArray): array of oil mass ratio in ng oil / g ice on the vertical grid\n        ice_scattering_coefficient (float): scattering coefficient for ice in 1/m\n        median_droplet_radius_in_microns (float): median droplet radius in microns\n        absorption_enhancement_factor (float): enhancement factor for oil absorption appropriate for the two-stream model\n        liquid_fraction (NDArray): liquid fraction array on the vertical grid\n        fast_solve (Bool): if True, solve the model only for wavelengths below a wavelength cutoff, assume longer wavelengths are absorbed at the surface\n        wavelength_cutoff (float): cutoff wavelength in nm\n    \"\"\"\n\n    z: NDArray\n    wavelengths: NDArray\n    oil_mass_ratio: NDArray\n    ice_scattering_coefficient: float\n    median_droplet_radius_in_microns: float\n    absorption_enhancement_factor: float = 1\n    liquid_fraction: Optional[NDArray] = None\n    fast_solve: bool = False\n    wavelength_cutoff: Optional[float] = None\n\n    def __post_init__(self):\n        # initialise liquid fraction as zero everywhere if not provided\n        if self.liquid_fraction is None:\n            self.liquid_fraction = np.full_like(self.z, 0)\n\n        # find the index of the ice ocean interface\n        self._ice_base_index = np.argmax(self.liquid_fraction &lt; 1)\n</code></pre>"},{"location":"#oilrad.infinite_layer.solve_at_given_wavelength","title":"<code>solve_at_given_wavelength(model, wavelength)</code>","text":"<p>Use the scipy solve_bcp function to solve the two-stream model as a function of depth for a given wavelenght value.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>InfiniteLayerModel</code> <p>model parameters</p> required <code>wavelength</code> <code>float</code> <p>wavelength in nm</p> required <p>Returns:     tuple[NDArray, NDArray]: upwelling and downwelling irradiances as functions of depth Raises:     RuntimeError: if the solver does not converge</p> Source code in <code>oilrad/infinite_layer.py</code> <pre><code>def solve_at_given_wavelength(model, wavelength: float) -&gt; tuple[NDArray, NDArray]:\n    \"\"\"Use the scipy solve_bcp function to solve the two-stream model as a function of\n    depth for a given wavelenght value.\n\n    Args:\n        model (InfiniteLayerModel): model parameters\n        wavelength (float): wavelength in nm\n    Returns:\n        tuple[NDArray, NDArray]: upwelling and downwelling irradiances as functions of depth\n    Raises:\n        RuntimeError: if the solver does not converge\n    \"\"\"\n    fun = _get_ODE_fun(model, wavelength)\n    solution = solve_bvp(\n        fun,\n        _BCs,\n        np.linspace(model.z[0], model.z[-1], 5),\n        np.zeros((2, 5)),\n        max_nodes=12000,\n    )\n    if not solution.success:\n        raise RuntimeError(f\"{solution.message}\")\n    return solution.sol(model.z)[0], solution.sol(model.z)[1]\n</code></pre>"},{"location":"#oilrad.irradiance","title":"<code>irradiance</code>","text":"<p>Classes to store solution of two stream spectral model and integrate over a given incident shortwave spectrum to return spectrally integrated properties of the solution.</p>"},{"location":"#oilrad.irradiance.Irradiance","title":"<code>Irradiance</code>  <code>dataclass</code>","text":"<p>One dimensional Arrays containing the upwelling and downwelling irradiances at each depth integrated over wavelength.</p> <p>Irradiances are non-dimensional and need to be multiplied by the incident spectral radiation.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>NDArray</code> <p>vertical grid specified in dimensional units (m)</p> required <code>upwelling</code> <code>NDArray</code> <p>1D array of integrated upwelling irradiances</p> required <code>downwelling</code> <code>NDArray</code> <p>1D array of integrated downwelling irradiances</p> required Source code in <code>oilrad/irradiance.py</code> <pre><code>@dataclass(frozen=True)\nclass Irradiance:\n    \"\"\"One dimensional Arrays containing the upwelling and downwelling irradiances at each\n    depth integrated over wavelength.\n\n    Irradiances are non-dimensional and need to be multiplied by the incident spectral radiation.\n\n    Args:\n        z (NDArray): vertical grid specified in dimensional units (m)\n        upwelling (NDArray): 1D array of integrated upwelling irradiances\n        downwelling (NDArray): 1D array of integrated downwelling irradiances\n    \"\"\"\n\n    z: NDArray\n    upwelling: NDArray\n    downwelling: NDArray\n\n    _ice_base_index: int = 0\n\n    @property\n    def net_irradiance(self) -&gt; NDArray:\n        \"\"\"Calculate net irradiance\"\"\"\n        return self.downwelling - self.upwelling\n\n    @property\n    def albedo(self) -&gt; NDArray:\n        \"\"\"Calculate albedo\"\"\"\n        return self.upwelling[-1]\n\n    @property\n    def transmittance(self) -&gt; NDArray:\n        \"\"\"Calculate transmittance at the ice ocean interface or the bottom\n        of the domain if the domain is entirely ice.\"\"\"\n        return self.downwelling[self._ice_base_index]\n</code></pre>"},{"location":"#oilrad.irradiance.Irradiance.albedo","title":"<code>albedo: NDArray</code>  <code>property</code>","text":"<p>Calculate albedo</p>"},{"location":"#oilrad.irradiance.Irradiance.net_irradiance","title":"<code>net_irradiance: NDArray</code>  <code>property</code>","text":"<p>Calculate net irradiance</p>"},{"location":"#oilrad.irradiance.Irradiance.transmittance","title":"<code>transmittance: NDArray</code>  <code>property</code>","text":"<p>Calculate transmittance at the ice ocean interface or the bottom of the domain if the domain is entirely ice.</p>"},{"location":"#oilrad.irradiance.SpectralIrradiance","title":"<code>SpectralIrradiance</code>  <code>dataclass</code>","text":"<p>Two dimensional arrays containing the upwelling and downwelling irradiances at each depth and wavelength.</p> <p>Irradiances are non-dimensional and need to be multiplied by the incident spectral radiation.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>NDArray</code> <p>vertical grid specified in dimensional units (m)</p> required <code>wavelengths</code> <code>NDArray</code> <p>array of wavelengths in nm</p> required <code>upwelling</code> <code>NDArray</code> <p>2D array of upwelling irradiances</p> required <code>downwelling</code> <code>NDArray</code> <p>2D array of downwelling irradiances</p> required Source code in <code>oilrad/irradiance.py</code> <pre><code>@dataclass(frozen=True)\nclass SpectralIrradiance:\n    \"\"\"Two dimensional arrays containing the upwelling and downwelling irradiances at each\n    depth and wavelength.\n\n    Irradiances are non-dimensional and need to be multiplied by the incident spectral radiation.\n\n    Args:\n        z (NDArray): vertical grid specified in dimensional units (m)\n        wavelengths (NDArray): array of wavelengths in nm\n        upwelling (NDArray): 2D array of upwelling irradiances\n        downwelling (NDArray): 2D array of downwelling irradiances\n    \"\"\"\n\n    z: NDArray\n    wavelengths: NDArray\n    upwelling: NDArray\n    downwelling: NDArray\n\n    _ice_base_index: int = 0\n\n    @property\n    def net_irradiance(self) -&gt; NDArray:\n        \"\"\"Calculate spectral net irradiance\"\"\"\n        return self.downwelling - self.upwelling\n\n    @property\n    def albedo(self) -&gt; NDArray:\n        \"\"\"Calculate spectral albedo\"\"\"\n        return self.upwelling[-1, :]\n\n    @property\n    def transmittance(self) -&gt; NDArray:\n        \"\"\"Calculate spectral transmittance at the ice ocean interface or the bottom\n        of the domain if the domain is entirely ice.\"\"\"\n        return self.downwelling[self._ice_base_index, :]\n</code></pre>"},{"location":"#oilrad.irradiance.SpectralIrradiance.albedo","title":"<code>albedo: NDArray</code>  <code>property</code>","text":"<p>Calculate spectral albedo</p>"},{"location":"#oilrad.irradiance.SpectralIrradiance.net_irradiance","title":"<code>net_irradiance: NDArray</code>  <code>property</code>","text":"<p>Calculate spectral net irradiance</p>"},{"location":"#oilrad.irradiance.SpectralIrradiance.transmittance","title":"<code>transmittance: NDArray</code>  <code>property</code>","text":"<p>Calculate spectral transmittance at the ice ocean interface or the bottom of the domain if the domain is entirely ice.</p>"},{"location":"#oilrad.irradiance.integrate_over_SW","title":"<code>integrate_over_SW(spectral_irradiance, spectrum)</code>","text":"<p>Integrate over the spectral two-stream model solution over a given incident shortwave spectrum</p> <p>Parameters:</p> Name Type Description Default <code>spectral_irradiance</code> <code>SpectralIrradiance</code> <p>spectral two-stream model solution</p> required <code>spectrum</code> <code>BlackBodySpectrum</code> <p>incident shortwave spectrum</p> required <p>Returns:     Irradiance: spectrally integrated irradiances</p> Source code in <code>oilrad/irradiance.py</code> <pre><code>def integrate_over_SW(\n    spectral_irradiance: SpectralIrradiance, spectrum: BlackBodySpectrum\n) -&gt; Irradiance:\n    \"\"\"Integrate over the spectral two-stream model solution over a given incident\n    shortwave spectrum\n\n    Args:\n        spectral_irradiance (SpectralIrradiance): spectral two-stream model solution\n        spectrum (BlackBodySpectrum): incident shortwave spectrum\n    Returns:\n        Irradiance: spectrally integrated irradiances\n    \"\"\"\n    wavelengths = spectral_irradiance.wavelengths\n    integrate = lambda irradiance: trapezoid(\n        irradiance * spectrum(wavelengths), wavelengths, axis=1\n    )\n    integrated_upwelling = integrate(spectral_irradiance.upwelling)\n    integrated_downwelling = integrate(spectral_irradiance.downwelling)\n    return Irradiance(\n        spectral_irradiance.z,\n        integrated_upwelling,\n        integrated_downwelling,\n        _ice_base_index=spectral_irradiance._ice_base_index,\n    )\n</code></pre>"},{"location":"#oilrad.optics","title":"<code>optics</code>","text":"<p>Module to calculate the optical properties for ice containing oil droplets: - The spectral absorption coefficient which depends on oil mass concentration and droplet size - The wavelength-independent scattering coefficient which takes a constant value in the ice and is zero the liquid</p> <p>Load data for imaginary refractive index against wavelength from doi:10.1029/2007JD009744. This is used to calculate the absorption coefficient of pure ice. To interpolate the data to other wavelengths should interpolate the log of the data linearly.</p> <p>Oil absorption calculated following Redmond Roche et al 2022 using given data for mass absorption coefficient of oil in ice which is a function of wavelength and droplet radius</p>"},{"location":"#oilrad.optics.calculate_ice_oil_absorption_coefficient","title":"<code>calculate_ice_oil_absorption_coefficient(wavelengths_in_nm, oil_mass_ratio, droplet_radius_in_microns, absorption_enhancement_factor=1.0)</code>","text":"<p>Calculate the absorption coefficient in 1/m of ice polluted with oil droplets following roche et al 2022. The oil droplets radii are distributed log-normally with geometric standard deviation e. We specify the median radius for the distribution.</p> <p>mass ratio in units of ng oil / g ice</p> <p>This is for Romashkino oil.</p> <p>The enahncement factor is an ad hoc correction for the two stream model to try and better match the results of redmondroche2022 which used an 8-stream model</p> <p>Parameters:</p> Name Type Description Default <code>wavelengths_in_nm</code> <code>NDArray</code> <p>wavelengths in nm</p> required <code>oil_mass_ratio</code> <code>float</code> <p>mass ratio of oil in ice in ng/g</p> required <code>droplet_radius_in_microns</code> <code>float</code> <p>median droplet radius in microns</p> required <code>absorption_enhancement_factor</code> <code>float</code> <p>enhancement factor for absorption coefficient. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <p>absorption coefficient in 1/m</p> Source code in <code>oilrad/optics.py</code> <pre><code>def calculate_ice_oil_absorption_coefficient(\n    wavelengths_in_nm,\n    oil_mass_ratio,\n    droplet_radius_in_microns,\n    absorption_enhancement_factor=1.0,\n):\n    \"\"\"Calculate the absorption coefficient in 1/m of ice polluted with oil droplets\n    following roche et al 2022. The oil droplets radii are distributed log-normally\n    with geometric standard deviation e. We specify the median radius for the distribution.\n\n    mass ratio in units of ng oil / g ice\n\n    This is for Romashkino oil.\n\n    The enahncement factor is an ad hoc correction for the two stream model to try and\n    better match the results of redmondroche2022 which used an 8-stream model\n\n    Args:\n        wavelengths_in_nm (NDArray): wavelengths in nm\n        oil_mass_ratio (float): mass ratio of oil in ice in ng/g\n        droplet_radius_in_microns (float): median droplet radius in microns\n        absorption_enhancement_factor (float, optional): enhancement factor for absorption coefficient. Defaults to 1.0.\n\n    Returns:\n        NDArray: absorption coefficient in 1/m\n    \"\"\"\n    ICE_DENSITY_ROCHE_2022 = 800  # in kg/m3\n    mass_ratio_dimensionless = oil_mass_ratio * 1e-9\n    return absorption_enhancement_factor * (\n        _calculate_ice_absorption_coefficient(wavelengths_in_nm)\n        + mass_ratio_dimensionless\n        * 1e3\n        * ICE_DENSITY_ROCHE_2022\n        * _Romashkino_MAC(wavelengths_in_nm, droplet_radius_in_microns)\n    )\n</code></pre>"},{"location":"#oilrad.optics.calculate_scattering","title":"<code>calculate_scattering(liquid_fraction, ice_scattering_coefficient)</code>","text":"<p>Calculate scattering coefficient in ice and return zero in liquid. (doesn't depend on wavelength)</p> <p>Smoothly transitions from the ice_scattering_coefficient to zero in the liquid using a tanh function.</p> <p>Parameters:</p> Name Type Description Default <code>liquid_fraction</code> <code>NDArray</code> <p>liquid fraction as a function of depth</p> required <code>ice_scattering_coefficient</code> <code>float</code> <p>scattering coefficient of ice</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <p>scattering coefficient [1/m] as a function of depth</p> Source code in <code>oilrad/optics.py</code> <pre><code>def calculate_scattering(liquid_fraction: NDArray, ice_scattering_coefficient: float):\n    \"\"\"Calculate scattering coefficient in ice and return zero in liquid.\n    (doesn't depend on wavelength)\n\n    Smoothly transitions from the ice_scattering_coefficient to zero in the liquid using a tanh function.\n\n    Args:\n        liquid_fraction (NDArray): liquid fraction as a function of depth\n        ice_scattering_coefficient (float): scattering coefficient of ice\n\n    Returns:\n        NDArray: scattering coefficient [1/m] as a function of depth\n    \"\"\"\n\n    return ice_scattering_coefficient * np.tanh((1 - liquid_fraction) * 100)\n</code></pre>"},{"location":"#oilrad.solve","title":"<code>solve</code>","text":"<p>Provide a function to solve the two-stream model in the case of continuously varying optical properties which implements a faster solve approximation for long wavelengths if the fast_solve parameter of the model is set to True.</p>"},{"location":"#oilrad.solve.solve_two_stream_model","title":"<code>solve_two_stream_model(model)</code>","text":"<p>Solve the two-stream model and return an object containing the solution at all specified wavelengths</p> <p>Args (InfiniteLayerModel):     model: two-stream model parameters</p> <p>Returns:</p> Name Type Description <code>SpectralIrradiance</code> <code>SpectralIrradiance</code> <p>object containing the solution of the two-stream model at each wavelength</p> Source code in <code>oilrad/solve.py</code> <pre><code>def solve_two_stream_model(\n    model: InfiniteLayerModel,\n) -&gt; SpectralIrradiance:\n    \"\"\"Solve the two-stream model and return an object containing the solution at all\n    specified wavelengths\n\n    Args (InfiniteLayerModel):\n        model: two-stream model parameters\n\n    Returns:\n        SpectralIrradiance: object containing the solution of the two-stream model at each wavelength\n    \"\"\"\n\n    upwelling = np.empty((model.z.size, model.wavelengths.size))\n    downwelling = np.empty((model.z.size, model.wavelengths.size))\n    if model.fast_solve:\n        cut_off_index = (\n            np.argmin(np.abs(model.wavelengths - model.wavelength_cutoff)) + 1\n        )\n        is_surface = np.s_[cut_off_index:]\n        is_interior = np.s_[:cut_off_index]\n        for i, wavelength in enumerate(model.wavelengths[is_interior]):\n            col_upwelling, col_downwelling = solve_at_given_wavelength(\n                model, wavelength\n            )\n            upwelling[:, i] = col_upwelling\n            downwelling[:, i] = col_downwelling\n\n        upwelling[:, is_surface] = 0\n        downwelling[:, is_surface] = 0\n        downwelling[-1, is_surface] = 1\n    else:\n        for i, wavelength in enumerate(model.wavelengths):\n            col_upwelling, col_downwelling = solve_at_given_wavelength(\n                model, wavelength\n            )\n            upwelling[:, i] = col_upwelling\n            downwelling[:, i] = col_downwelling\n    return SpectralIrradiance(\n        model.z, model.wavelengths, upwelling, downwelling, model._ice_base_index\n    )\n</code></pre>"},{"location":"#oilrad.spectra","title":"<code>spectra</code>","text":"<p>Module to provide the spectrum of incident downwelling shortwave radiation at the top of the domain.</p> <p>Currently only the black body spectrum is integrated which follows the solar spectrum at the top of the atmosphere, but is normalised to integrate to one in the shortwave range.</p> <p>Data used to compute the Planck function is from: https://www.oceanopticsbook.info/view/light-and-radiometry/level-2/light-from-the-sun</p>"},{"location":"#oilrad.spectra.BlackBodySpectrum","title":"<code>BlackBodySpectrum</code>  <code>dataclass</code>","text":"<p>Spectrum with blackbody shape that integrates to 1 between minimum and maximum wavelength specified in nm</p> <p>Once initialised the spectrum can be called with an array of wavelengths in nm.</p> <p>Parameters:</p> Name Type Description Default <code>min_wavelength</code> <code>float</code> <p>minimum wavelength in nm</p> required <code>max_wavelength</code> <code>float</code> <p>maximum wavelength in nm</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if wavelength is not in the shortwave range</p> Source code in <code>oilrad/spectra.py</code> <pre><code>@dataclass(frozen=True)\nclass BlackBodySpectrum:\n    \"\"\"Spectrum with blackbody shape that integrates to 1 between minimum and maximum\n    wavelength specified in nm\n\n    Once initialised the spectrum can be called with an array of wavelengths in nm.\n\n    Args:\n        min_wavelength: minimum wavelength in nm\n        max_wavelength: maximum wavelength in nm\n\n    Raises:\n        ValueError: if wavelength is not in the shortwave range\n    \"\"\"\n\n    min_wavelength: float\n    max_wavelength: float\n\n    @cached_property\n    def _total_irradiance(self) -&gt; float:\n        return quad(\n            self._top_of_atmosphere_irradiance, self.min_wavelength, self.max_wavelength\n        )[0]\n\n    @classmethod\n    def _top_of_atmosphere_irradiance(cls, wavelength_in_nm):\n        \"\"\"For wavelength in nm and temperature in K return top of atmosphere solar\n        irradiance in W/m2 nm\n        https://www.oceanopticsbook.info/view/light-and-radiometry/level-2/blackbody-radiation\n        \"\"\"\n        return (\n            PLANCK_FUNCTION(wavelength_in_nm * 1e-9, T=5782)\n            * (SUN_RADIUS**2 / AU**2)\n            * np.pi\n            * 1e-9\n        )\n\n    def __call__(self, wavelength_in_nm: NDArray) -&gt; NDArray:\n        if np.any(wavelength_in_nm &gt; self.max_wavelength) or np.any(\n            wavelength_in_nm &lt; self.min_wavelength\n        ):\n            raise ValueError(\n                f\"wavelength not in shortwave range {self.min_wavelength}nm - {self.max_wavelength}nm\"\n            )\n        return (\n            self._top_of_atmosphere_irradiance(wavelength_in_nm)\n            / self._total_irradiance\n        )\n</code></pre>"}]}