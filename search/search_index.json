{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"API Reference","text":"<p>Two-stream shortwave radiative transfer model for sea ice containing oil droplets.</p>"},{"location":"#oilrad.constants","title":"<code>constants</code>","text":"<p>Constants used in the program</p>"},{"location":"#oilrad.cts_wavelength","title":"<code>cts_wavelength</code>","text":""},{"location":"#oilrad.cts_wavelength.irradiances","title":"<code>irradiances</code>","text":"<p>Classes to store the solution of the continuous wavelength two stream model. Spectral irradiances and the integrated irradiances noralised by the incident.</p>"},{"location":"#oilrad.cts_wavelength.irradiances.CtsWavelengthIrradiance","title":"<code>CtsWavelengthIrradiance</code>  <code>dataclass</code>","text":"<p>One dimensional Arrays containing the upwelling and downwelling irradiances at each depth integrated over wavelength.</p> <p>Irradiances are non-dimensional and need to be multiplied by the incident spectral radiation.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>NDArray</code> <p>vertical grid specified in dimensional units (m)</p> required <code>upwelling</code> <code>NDArray</code> <p>1D array of integrated upwelling irradiances</p> required <code>downwelling</code> <code>NDArray</code> <p>1D array of integrated downwelling irradiances</p> required Source code in <code>oilrad/cts_wavelength/irradiances.py</code> <pre><code>@dataclass(frozen=True)\nclass CtsWavelengthIrradiance:\n    \"\"\"One dimensional Arrays containing the upwelling and downwelling irradiances at each\n    depth integrated over wavelength.\n\n    Irradiances are non-dimensional and need to be multiplied by the incident spectral radiation.\n\n    Args:\n        z (NDArray): vertical grid specified in dimensional units (m)\n        upwelling (NDArray): 1D array of integrated upwelling irradiances\n        downwelling (NDArray): 1D array of integrated downwelling irradiances\n    \"\"\"\n\n    z: NDArray\n    upwelling: NDArray\n    downwelling: NDArray\n\n    _ice_base_index: int = 0\n\n    @property\n    def net_irradiance(self) -&gt; NDArray:\n        \"\"\"Calculate net irradiance\"\"\"\n        return self.downwelling - self.upwelling\n\n    @property\n    def albedo(self) -&gt; NDArray:\n        \"\"\"Calculate albedo\"\"\"\n        return self.upwelling[-1]\n\n    @property\n    def transmittance(self) -&gt; NDArray:\n        \"\"\"Calculate transmittance at the ice ocean interface or the bottom\n        of the domain if the domain is entirely ice.\"\"\"\n        return self.downwelling[self._ice_base_index]\n</code></pre>"},{"location":"#oilrad.cts_wavelength.irradiances.CtsWavelengthIrradiance.albedo","title":"<code>albedo</code>  <code>property</code>","text":"<p>Calculate albedo</p>"},{"location":"#oilrad.cts_wavelength.irradiances.CtsWavelengthIrradiance.net_irradiance","title":"<code>net_irradiance</code>  <code>property</code>","text":"<p>Calculate net irradiance</p>"},{"location":"#oilrad.cts_wavelength.irradiances.CtsWavelengthIrradiance.transmittance","title":"<code>transmittance</code>  <code>property</code>","text":"<p>Calculate transmittance at the ice ocean interface or the bottom of the domain if the domain is entirely ice.</p>"},{"location":"#oilrad.cts_wavelength.irradiances.CtsWavelengthSpectralIrradiance","title":"<code>CtsWavelengthSpectralIrradiance</code>  <code>dataclass</code>","text":"<p>Two dimensional arrays containing the upwelling and downwelling irradiances at each depth and wavelength.</p> <p>Irradiances are non-dimensional and need to be multiplied by the incident spectral radiation.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>NDArray</code> <p>vertical grid specified in dimensional units (m)</p> required <code>wavelengths</code> <code>NDArray</code> <p>array of wavelengths in nm</p> required <code>upwelling</code> <code>NDArray</code> <p>2D array of upwelling irradiances</p> required <code>downwelling</code> <code>NDArray</code> <p>2D array of downwelling irradiances</p> required Source code in <code>oilrad/cts_wavelength/irradiances.py</code> <pre><code>@dataclass(frozen=True)\nclass CtsWavelengthSpectralIrradiance:\n    \"\"\"Two dimensional arrays containing the upwelling and downwelling irradiances at\n    each depth and wavelength.\n\n    Irradiances are non-dimensional and need to be multiplied by the incident spectral\n    radiation.\n\n    Args:\n        z (NDArray): vertical grid specified in dimensional units (m)\n        wavelengths (NDArray): array of wavelengths in nm\n        upwelling (NDArray): 2D array of upwelling irradiances\n        downwelling (NDArray): 2D array of downwelling irradiances\n    \"\"\"\n\n    z: NDArray\n    wavelengths: NDArray\n    upwelling: NDArray\n    downwelling: NDArray\n\n    _ice_base_index: int = 0\n\n    @property\n    def net_irradiance(self) -&gt; NDArray:\n        return self.downwelling - self.upwelling\n\n    @property\n    def albedo(self) -&gt; NDArray:\n        \"\"\"Calculate spectral albedo\"\"\"\n        return self.upwelling[-1, :]\n\n    @property\n    def transmittance(self) -&gt; NDArray:\n        \"\"\"Calculate spectral transmittance at the ice ocean interface or the bottom\n        of the domain if the domain is entirely ice.\"\"\"\n        return self.downwelling[self._ice_base_index, :]\n</code></pre>"},{"location":"#oilrad.cts_wavelength.irradiances.CtsWavelengthSpectralIrradiance.albedo","title":"<code>albedo</code>  <code>property</code>","text":"<p>Calculate spectral albedo</p>"},{"location":"#oilrad.cts_wavelength.irradiances.CtsWavelengthSpectralIrradiance.transmittance","title":"<code>transmittance</code>  <code>property</code>","text":"<p>Calculate spectral transmittance at the ice ocean interface or the bottom of the domain if the domain is entirely ice.</p>"},{"location":"#oilrad.cts_wavelength.model","title":"<code>model</code>","text":"<p>Solve the two-stream shortwave radiation model for a layer of ice with constant optical properties aside from absorption varying due to the oil mass ratio.</p> <p>Arbitrary wavelength resolution</p>"},{"location":"#oilrad.cts_wavelength.model.CtsWavelengthModel","title":"<code>CtsWavelengthModel</code>  <code>dataclass</code>","text":"<p>Class containing all the necessary parameters to solve the two-stream shortwave radiative transfer model in a domain with continuously varying liquid fraction and oil mass ratio.</p> <p>If no array is provided for liquid fraction, it is assumed to be zero everywhere. This corresponds to a completely frozen domain.</p> <p>Oil mass ratio is provided in ng oil / g ice and, along with the median droplet radius for the oil droplet distribution, is used to calculate the absorption coefficient by interpolating data for Romashkino oil from Redmond Roche et al. 2022.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>NDArray</code> <p>vertical grid in meters</p> required <code>wavelengths</code> <code>NDArray</code> <p>array of wavelengths in nm</p> required <code>oil_mass_ratio</code> <code>NDArray</code> <p>array of oil mass ratio in ng oil / g ice on the vertical grid</p> required <code>ice_scattering_coefficient</code> <code>float</code> <p>scattering coefficient for ice in 1/m</p> required <code>median_droplet_radius_in_microns</code> <code>float</code> <p>median droplet radius in microns</p> required <code>absorption_enhancement_factor</code> <code>float</code> <p>enhancement factor for oil absorption appropriate for the two-stream model</p> <code>1</code> <code>liquid_fraction</code> <code>NDArray</code> <p>liquid fraction array on the vertical grid</p> <code>None</code> <code>fast_solve</code> <code>Bool</code> <p>if True, solve the model only for wavelengths below a wavelength cutoff, assume longer wavelengths are absorbed at the surface</p> <code>False</code> <code>wavelength_cutoff</code> <code>float</code> <p>cutoff wavelength in nm</p> <code>None</code> Source code in <code>oilrad/cts_wavelength/model.py</code> <pre><code>@dataclass\nclass CtsWavelengthModel:\n    \"\"\"Class containing all the necessary parameters to solve the two-stream shortwave\n    radiative transfer model in a domain with continuously varying liquid fraction and\n    oil mass ratio.\n\n    If no array is provided for liquid fraction, it is assumed to be zero everywhere.\n    This corresponds to a completely frozen domain.\n\n    Oil mass ratio is provided in ng oil / g ice and, along with the median droplet radius\n    for the oil droplet distribution, is used to calculate the absorption coefficient\n    by interpolating data for Romashkino oil from Redmond Roche et al. 2022.\n\n    Args:\n        z (NDArray): vertical grid in meters\n        wavelengths (NDArray): array of wavelengths in nm\n        oil_mass_ratio (NDArray): array of oil mass ratio in ng oil / g ice on the vertical grid\n        ice_scattering_coefficient (float): scattering coefficient for ice in 1/m\n        median_droplet_radius_in_microns (float): median droplet radius in microns\n        absorption_enhancement_factor (float): enhancement factor for oil absorption appropriate for the two-stream model\n        liquid_fraction (NDArray): liquid fraction array on the vertical grid\n        fast_solve (Bool): if True, solve the model only for wavelengths below a wavelength cutoff, assume longer wavelengths are absorbed at the surface\n        wavelength_cutoff (float): cutoff wavelength in nm\n    \"\"\"\n\n    z: NDArray\n    wavelengths: NDArray\n    oil_mass_ratio: NDArray\n    ice_scattering_coefficient: float\n    median_droplet_radius_in_microns: float\n    absorption_enhancement_factor: float = 1\n    liquid_fraction: Optional[NDArray] = None\n    fast_solve: bool = False\n    wavelength_cutoff: Optional[float] = None\n\n    def __post_init__(self):\n        # initialise liquid fraction as zero everywhere if not provided\n        if self.liquid_fraction is None:\n            self.liquid_fraction = np.full_like(self.z, 0)\n\n        # find the index of the ice ocean interface\n        self._ice_base_index = np.argmax(self.liquid_fraction &lt; 1)\n</code></pre>"},{"location":"#oilrad.cts_wavelength.model.solve_at_given_wavelength","title":"<code>solve_at_given_wavelength(model, wavelength)</code>","text":"<p>Use the scipy solve_bvp function to solve the two-stream model as a function of depth for a given wavelenght value.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>CtsWavelengthModel</code> <p>model parameters</p> required <code>wavelength</code> <code>float</code> <p>wavelength in nm</p> required <p>Returns:     tuple[NDArray, NDArray]: upwelling and downwelling irradiances as functions of depth Raises:     RuntimeError: if the solver does not converge</p> Source code in <code>oilrad/cts_wavelength/model.py</code> <pre><code>def solve_at_given_wavelength(model, wavelength: float) -&gt; tuple[NDArray, NDArray]:\n    \"\"\"Use the scipy solve_bvp function to solve the two-stream model as a function of\n    depth for a given wavelenght value.\n\n    Args:\n        model (CtsWavelengthModel): model parameters\n        wavelength (float): wavelength in nm\n    Returns:\n        tuple[NDArray, NDArray]: upwelling and downwelling irradiances as functions of depth\n    Raises:\n        RuntimeError: if the solver does not converge\n    \"\"\"\n    fun = _get_ODE_fun(model, wavelength)\n    solution = solve_bvp(\n        fun,\n        _BCs,\n        np.linspace(model.z[0], model.z[-1], 5),\n        np.zeros((2, 5)),\n        max_nodes=12000,\n    )\n    if not solution.success:\n        raise RuntimeError(f\"{solution.message}\")\n    return solution.sol(model.z)[0], solution.sol(model.z)[1]\n</code></pre>"},{"location":"#oilrad.integrate","title":"<code>integrate</code>","text":"<p>Spectrally integrate two-stream model solutions</p>"},{"location":"#oilrad.integrate.integrate_over_SW","title":"<code>integrate_over_SW(spectral_irradiance, spectrum=None)</code>","text":"<p>Spectrally integrate the two-stream model solution</p> <p>When integrating the continuous wavelength model need to supply an instance of the BlackBodySpectrum</p> <p>Integration of the six band model uses the cloudy incident spectrum of Grenfell et al 2004.</p> <p>Parameters:</p> Name Type Description Default <code>spectral_irradiance</code> <code>SpectralIrradiance | SixBandSpectralIrradiance</code> <p>spectral two-stream model solution</p> required <code>spectrum</code> <code>Optional[BlackBodySpectrum]</code> <p>normalised incident shortwave spectrum (only needed when integrating SpectralIrradiance). Currently only the BlackBodySpectrum is implemented.</p> <code>None</code> <p>Returns:     Irradiance | SixBandIrradiance: spectrally integrated irradiances</p> Source code in <code>oilrad/integrate.py</code> <pre><code>def integrate_over_SW(\n    spectral_irradiance: CtsWavelengthSpectralIrradiance | SixBandSpectralIrradiance,\n    spectrum: Optional[BlackBodySpectrum] = None,\n) -&gt; CtsWavelengthIrradiance | SixBandIrradiance:\n    \"\"\"Spectrally integrate the two-stream model solution\n\n    When integrating the continuous wavelength model need to supply an instance of the\n    BlackBodySpectrum\n\n    Integration of the six band model uses the cloudy incident spectrum of Grenfell\n    et al 2004.\n\n    Args:\n        spectral_irradiance (SpectralIrradiance | SixBandSpectralIrradiance):\n            spectral two-stream model solution\n        spectrum (Optional[BlackBodySpectrum]): normalised incident shortwave spectrum\n            (only needed when integrating SpectralIrradiance).\n            Currently only the BlackBodySpectrum is implemented.\n    Returns:\n        Irradiance | SixBandIrradiance: spectrally integrated irradiances\n    \"\"\"\n    if isinstance(spectral_irradiance, CtsWavelengthSpectralIrradiance):\n        if spectrum is None:\n            raise ValueError(\"spectrum must be provided\")\n        wavelengths = spectral_irradiance.wavelengths\n        integrate = lambda irradiance: trapezoid(\n            irradiance * spectrum(wavelengths), wavelengths, axis=1\n        )\n        integrated_upwelling = integrate(spectral_irradiance.upwelling)\n        integrated_downwelling = integrate(spectral_irradiance.downwelling)\n        return CtsWavelengthIrradiance(\n            spectral_irradiance.z,\n            integrated_upwelling,\n            integrated_downwelling,\n            _ice_base_index=spectral_irradiance._ice_base_index,\n        )\n    if isinstance(spectral_irradiance, SixBandSpectralIrradiance):\n        integrate = lambda x: np.sum(x * CLOUDY_SKY_FRACTIONS, axis=1)\n        return SixBandIrradiance(\n            spectral_irradiance.z,\n            integrate(spectral_irradiance.upwelling),\n            integrate(spectral_irradiance.downwelling),\n            np.sum(CLOUDY_SKY_FRACTIONS * spectral_irradiance.albedo),\n            _ice_base_index=spectral_irradiance._ice_base_index,\n        )\n    raise NotImplementedError()\n</code></pre>"},{"location":"#oilrad.optics","title":"<code>optics</code>","text":"<p>Module to calculate the optical properties for ice containing oil droplets: - The spectral absorption coefficient which depends on oil mass concentration and droplet size - The wavelength-independent scattering coefficient which takes a constant value in the ice and is zero the liquid</p> <p>Load data for imaginary refractive index against wavelength from doi:10.1029/2007JD009744. This is used to calculate the absorption coefficient of pure ice. To interpolate the data to other wavelengths should interpolate the log of the data linearly.</p> <p>Oil absorption calculated following Redmond Roche et al 2022 using given data for mass absorption coefficient of oil in ice which is a function of wavelength and droplet radius</p>"},{"location":"#oilrad.optics.calculate_ice_absorption_coefficient","title":"<code>calculate_ice_absorption_coefficient(wavelength_in_nm)</code>","text":"<p>calculate ice absorption coefficient from Warren 2008 data at given wavelengths inputted in nano meters from interpolated imaginary refractive index data</p> Source code in <code>oilrad/optics.py</code> <pre><code>def calculate_ice_absorption_coefficient(wavelength_in_nm):\n    \"\"\"calculate ice absorption coefficient from Warren 2008 data at given\n    wavelengths inputted in nano meters from interpolated imaginary refractive index\n    data\"\"\"\n    wavelengths_in_m = wavelength_in_nm * 1e-9\n    imaginary_refractive_index = _calculate_ice_imaginary_refractive_index(\n        wavelength_in_nm * 1e-3\n    )\n    absorption_coefficient = 4 * np.pi * imaginary_refractive_index / wavelengths_in_m\n    return absorption_coefficient\n</code></pre>"},{"location":"#oilrad.optics.calculate_ice_oil_absorption_coefficient","title":"<code>calculate_ice_oil_absorption_coefficient(wavelengths_in_nm, oil_mass_ratio, droplet_radius_in_microns, absorption_enhancement_factor=1.0)</code>","text":"<p>Calculate the absorption coefficient in 1/m of ice polluted with oil droplets following roche et al 2022. The oil droplets radii are distributed log-normally with geometric standard deviation e. We specify the median radius for the distribution.</p> <p>mass ratio in units of ng oil / g ice</p> <p>This is for Romashkino oil.</p> <p>The enahncement factor is an ad hoc correction for the two stream model to try and better match the results of redmondroche2022 which used an 8-stream model</p> <p>Parameters:</p> Name Type Description Default <code>wavelengths_in_nm</code> <code>NDArray</code> <p>wavelengths in nm</p> required <code>oil_mass_ratio</code> <code>float</code> <p>mass ratio of oil in ice in ng/g</p> required <code>droplet_radius_in_microns</code> <code>float</code> <p>median droplet radius in microns</p> required <code>absorption_enhancement_factor</code> <code>float</code> <p>enhancement factor for absorption coefficient. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <p>absorption coefficient in 1/m</p> Source code in <code>oilrad/optics.py</code> <pre><code>def calculate_ice_oil_absorption_coefficient(\n    wavelengths_in_nm,\n    oil_mass_ratio,\n    droplet_radius_in_microns,\n    absorption_enhancement_factor=1.0,\n):\n    \"\"\"Calculate the absorption coefficient in 1/m of ice polluted with oil droplets\n    following roche et al 2022. The oil droplets radii are distributed log-normally\n    with geometric standard deviation e. We specify the median radius for the distribution.\n\n    mass ratio in units of ng oil / g ice\n\n    This is for Romashkino oil.\n\n    The enahncement factor is an ad hoc correction for the two stream model to try and\n    better match the results of redmondroche2022 which used an 8-stream model\n\n    Args:\n        wavelengths_in_nm (NDArray): wavelengths in nm\n        oil_mass_ratio (float): mass ratio of oil in ice in ng/g\n        droplet_radius_in_microns (float): median droplet radius in microns\n        absorption_enhancement_factor (float, optional): enhancement factor for absorption coefficient. Defaults to 1.0.\n\n    Returns:\n        NDArray: absorption coefficient in 1/m\n    \"\"\"\n    mass_ratio_dimensionless = oil_mass_ratio * 1e-9\n    return absorption_enhancement_factor * (\n        calculate_ice_absorption_coefficient(wavelengths_in_nm)\n        + mass_ratio_dimensionless\n        * 1e3\n        * ICE_DENSITY_ROCHE_2022\n        * Romashkino_MAC(wavelengths_in_nm, droplet_radius_in_microns)\n    )\n</code></pre>"},{"location":"#oilrad.optics.calculate_scattering","title":"<code>calculate_scattering(liquid_fraction, ice_scattering_coefficient)</code>","text":"<p>Calculate scattering coefficient in ice and return zero in liquid. (doesn't depend on wavelength)</p> <p>Smoothly transitions from the ice_scattering_coefficient to zero in the liquid using a tanh function.</p> <p>Parameters:</p> Name Type Description Default <code>liquid_fraction</code> <code>NDArray</code> <p>liquid fraction as a function of depth</p> required <code>ice_scattering_coefficient</code> <code>float</code> <p>scattering coefficient of ice</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <p>scattering coefficient [1/m] as a function of depth</p> Source code in <code>oilrad/optics.py</code> <pre><code>def calculate_scattering(liquid_fraction: NDArray, ice_scattering_coefficient: float):\n    \"\"\"Calculate scattering coefficient in ice and return zero in liquid.\n    (doesn't depend on wavelength)\n\n    Smoothly transitions from the ice_scattering_coefficient to zero in the liquid using a tanh function.\n\n    Args:\n        liquid_fraction (NDArray): liquid fraction as a function of depth\n        ice_scattering_coefficient (float): scattering coefficient of ice\n\n    Returns:\n        NDArray: scattering coefficient [1/m] as a function of depth\n    \"\"\"\n\n    return ice_scattering_coefficient * np.tanh((1 - liquid_fraction) * 100)\n</code></pre>"},{"location":"#oilrad.six_band","title":"<code>six_band</code>","text":""},{"location":"#oilrad.six_band.irradiances","title":"<code>irradiances</code>","text":"<p>Classes to store spectral and integrated solution of the six band model. All irradiances are normalised by the incident.</p>"},{"location":"#oilrad.six_band.irradiances.SixBandIrradiance","title":"<code>SixBandIrradiance</code>  <code>dataclass</code>","text":"<p>One dimensional Arrays containing the upwelling and downwelling irradiances at each depth integrated over the wavelength bands.</p> <p>Irradiances are non-dimensional and need to be multiplied by the incident spectral radiation.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>NDArray</code> <p>vertical grid specified in dimensional units (m)</p> required <code>upwelling</code> <code>NDArray</code> <p>1D array of integrated upwelling irradiances</p> required <code>downwelling</code> <code>NDArray</code> <p>1D array of integrated downwelling irradiances</p> required <code>albedo</code> <code>float</code> <p>spectrally integrated albedo (including the snow layer and SSL)</p> required Source code in <code>oilrad/six_band/irradiances.py</code> <pre><code>@dataclass(frozen=True)\nclass SixBandIrradiance:\n    \"\"\"One dimensional Arrays containing the upwelling and downwelling irradiances at each\n    depth integrated over the wavelength bands.\n\n    Irradiances are non-dimensional and need to be multiplied by the incident spectral radiation.\n\n    Args:\n        z (NDArray): vertical grid specified in dimensional units (m)\n        upwelling (NDArray): 1D array of integrated upwelling irradiances\n        downwelling (NDArray): 1D array of integrated downwelling irradiances\n        albedo (float): spectrally integrated albedo (including the snow layer and SSL)\n    \"\"\"\n\n    z: NDArray\n    upwelling: NDArray\n    downwelling: NDArray\n    albedo: float\n\n    _ice_base_index: int = 0\n\n    @property\n    def net_irradiance(self) -&gt; NDArray:\n        return self.downwelling - self.upwelling\n\n    @property\n    def transmittance(self) -&gt; NDArray:\n        \"\"\"Calculate transmittance at the ice ocean interface or the bottom\n        of the domain if the domain is entirely ice.\"\"\"\n        return self.downwelling[self._ice_base_index]\n</code></pre>"},{"location":"#oilrad.six_band.irradiances.SixBandIrradiance.transmittance","title":"<code>transmittance</code>  <code>property</code>","text":"<p>Calculate transmittance at the ice ocean interface or the bottom of the domain if the domain is entirely ice.</p>"},{"location":"#oilrad.six_band.irradiances.SixBandSpectralIrradiance","title":"<code>SixBandSpectralIrradiance</code>  <code>dataclass</code>","text":"<p>Two dimensional arrays containing the upwelling and downwelling irradiances at each depth and in each wavelength band.</p> <p>Irradiances are non-dimensional and need to be multiplied by the incident spectral radiation.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>NDArray</code> <p>vertical grid specified in dimensional units (m)</p> required <code>upwelling</code> <code>NDArray</code> <p>2D array of upwelling irradiances</p> required <code>downwelling</code> <code>NDArray</code> <p>2D array of downwelling irradiances</p> required <code>albedo</code> <code>NDArray</code> <p>1D array of spectral albedo (including snow and SSL)</p> required Source code in <code>oilrad/six_band/irradiances.py</code> <pre><code>@dataclass(frozen=True)\nclass SixBandSpectralIrradiance:\n    \"\"\"Two dimensional arrays containing the upwelling and downwelling irradiances at\n    each depth and in each wavelength band.\n\n    Irradiances are non-dimensional and need to be multiplied by the incident spectral\n    radiation.\n\n    Args:\n        z (NDArray): vertical grid specified in dimensional units (m)\n        upwelling (NDArray): 2D array of upwelling irradiances\n        downwelling (NDArray): 2D array of downwelling irradiances\n        albedo (NDArray): 1D array of spectral albedo (including snow and SSL)\n    \"\"\"\n\n    z: NDArray\n    upwelling: NDArray\n    downwelling: NDArray\n    albedo: NDArray\n\n    _ice_base_index: int = 0\n\n    @property\n    def net_irradiance(self) -&gt; NDArray:\n        return self.downwelling - self.upwelling\n\n    @property\n    def transmittance(self) -&gt; NDArray:\n        \"\"\"Calculate spectral transmittance at the ice ocean interface or the bottom\n        of the domain if the domain is entirely ice.\"\"\"\n        return self.downwelling[self._ice_base_index, :]\n\n    @property\n    def PAR_transmittance(self) -&gt; NDArray:\n        \"\"\"Calculate plane PAR transmittance as the ratio of the\n        net irradiant power in the PAR range (400-700nm) to the incident\n        irradiative power at the ice / snow surface.\n        \"\"\"\n        return np.sum(\n            self.net_irradiance[:, 1:4] * CLOUDY_SKY_FRACTIONS[1:4], axis=1\n        ) / np.sum(CLOUDY_SKY_FRACTIONS[1:4])\n\n    @property\n    def plane_PAR(self) -&gt; NDArray:\n        \"\"\"Calculate plane PAR normalised by the incident broadband shortwave irradiance.\n\n        To convert to micromol-photns m^-2 s^-1 we need to multiply by the incident shortwave\n        irradiance in W m^-2.\n\n        To convert to the scalar value for an isotropic downwelling irradiance multiply\n        by a factor of 2.\n        \"\"\"\n        PAR_weightings = np.array(\n            [9.809215701925024e-08, 1.0750608149135324e-07, 1.0006054876321231e-07]\n        )\n        return (1e6 / (PLANCK * LIGHTSPEED * MOLE)) * np.sum(\n            (self.upwelling[:, 1:4] + self.downwelling[:, 1:4]) * PAR_weightings, axis=1\n        )\n\n    @property\n    def ice_base_PAR_transmittance(self) -&gt; float:\n        return self.PAR_transmittance[self._ice_base_index]\n\n    @property\n    def ice_base_plane_PAR(self) -&gt; float:\n        return self.plane_PAR[self._ice_base_index]\n</code></pre>"},{"location":"#oilrad.six_band.irradiances.SixBandSpectralIrradiance.PAR_transmittance","title":"<code>PAR_transmittance</code>  <code>property</code>","text":"<p>Calculate plane PAR transmittance as the ratio of the net irradiant power in the PAR range (400-700nm) to the incident irradiative power at the ice / snow surface.</p>"},{"location":"#oilrad.six_band.irradiances.SixBandSpectralIrradiance.plane_PAR","title":"<code>plane_PAR</code>  <code>property</code>","text":"<p>Calculate plane PAR normalised by the incident broadband shortwave irradiance.</p> <p>To convert to micromol-photns m^-2 s^-1 we need to multiply by the incident shortwave irradiance in W m^-2.</p> <p>To convert to the scalar value for an isotropic downwelling irradiance multiply by a factor of 2.</p>"},{"location":"#oilrad.six_band.irradiances.SixBandSpectralIrradiance.transmittance","title":"<code>transmittance</code>  <code>property</code>","text":"<p>Calculate spectral transmittance at the ice ocean interface or the bottom of the domain if the domain is entirely ice.</p>"},{"location":"#oilrad.six_band.model","title":"<code>model</code>","text":"<p>Shortwave radiative transfer model for a layer of sea ice with 6 spectral bands.</p> <p>Optionally the ice may have a melt pond layer, a snow layer and a surface scattering layer (SSL).</p>"},{"location":"#oilrad.six_band.model.SixBandModel","title":"<code>SixBandModel</code>  <code>dataclass</code>","text":"<p>Class containing all the necessary parameters to solve the two-stream shortwave radiative transfer model in a domain with continuously varying liquid fraction and oil mass ratio with optical properties averaged in the six spectral bands with wavelengths:</p> <p>300-400nm 400-500nm 500-600nm 600-700nm 700-1200nm 1200-3000nm</p> <p>Irradiances are scaled by the incident downwelling in each spectral band.</p> <p>If no array is provided for liquid fraction, it is assumed to be zero everywhere. This corresponds to a completely frozen domain.</p> <p>Oil mass ratio is provided in ng oil / g ice and, along with the median droplet radius for the oil droplet distribution, is used to calculate the absorption coefficient by interpolating data for Romashkino oil from Redmond Roche et al. 2022.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>NDArray</code> <p>vertical grid in meters</p> required <code>oil_mass_ratio</code> <code>NDArray</code> <p>array of oil mass ratio in ng oil / g ice on the vertical grid</p> required <code>ice_scattering_coefficient</code> <code>float</code> <p>scattering coefficient for ice in 1/m</p> required <code>median_droplet_radius_in_microns</code> <code>float</code> <p>median droplet radius in microns</p> required <code>absorption_enhancement_factor</code> <code>float</code> <p>enhancement factor for oil absorption appropriate for the two-stream model</p> required <code>snow_depth</code> <code>float</code> <p>snow depth in meters</p> required <code>snow_spectral_albedos</code> <code>NDArray</code> <p>spectral albedos for the snow layer in each band</p> required <code>snow_extinction_coefficients</code> <code>NDArray</code> <p>spectral extinction coefficient for the snow layer in each band</p> required <code>SSL_depth</code> <code>float</code> <p>depth of the surface scattering layer in meters</p> required <code>SSL_spectral_albedos</code> <code>NDArray</code> <p>spectral albedos for the SSL in each band</p> required <code>SSL_extinction_coefficients</code> <code>NDArray</code> <p>spectral extinction coefficients for the SSL in each band</p> required <code>liquid_fraction</code> <code>Optional[NDArray]</code> <p>liquid fraction array on the vertical grid</p> <code>None</code> Source code in <code>oilrad/six_band/model.py</code> <pre><code>@dataclass\nclass SixBandModel:\n    \"\"\"Class containing all the necessary parameters to solve the two-stream shortwave\n    radiative transfer model in a domain with continuously varying liquid fraction and\n    oil mass ratio with optical properties averaged in the six spectral bands with\n    wavelengths:\n\n    300-400nm\n    400-500nm\n    500-600nm\n    600-700nm\n    700-1200nm\n    1200-3000nm\n\n    Irradiances are scaled by the incident downwelling in each spectral band.\n\n    If no array is provided for liquid fraction, it is assumed to be zero everywhere.\n    This corresponds to a completely frozen domain.\n\n    Oil mass ratio is provided in ng oil / g ice and, along with the median droplet radius\n    for the oil droplet distribution, is used to calculate the absorption coefficient\n    by interpolating data for Romashkino oil from Redmond Roche et al. 2022.\n\n    Args:\n        z (NDArray): vertical grid in meters\n        oil_mass_ratio (NDArray): array of oil mass ratio in ng oil / g ice on the\n            vertical grid\n        ice_scattering_coefficient (float): scattering coefficient for ice in 1/m\n        median_droplet_radius_in_microns (float): median droplet radius in microns\n        absorption_enhancement_factor (float): enhancement factor for oil absorption\n            appropriate for the two-stream model\n        snow_depth (float): snow depth in meters\n        snow_spectral_albedos (NDArray): spectral albedos for the snow layer in each\n            band\n        snow_extinction_coefficients (NDArray): spectral extinction coefficient for the\n            snow layer in each band\n        SSL_depth (float): depth of the surface scattering layer in meters\n        SSL_spectral_albedos (NDArray): spectral albedos for the SSL in each band\n        SSL_extinction_coefficients (NDArray): spectral extinction coefficients for the\n            SSL in each band\n        liquid_fraction (Optional[NDArray]): liquid fraction array on the vertical grid\n    \"\"\"\n\n    z: NDArray\n    oil_mass_ratio: NDArray\n    ice_scattering_coefficient: float\n    median_droplet_radius_in_microns: float\n    absorption_enhancement_factor: float\n\n    snow_depth: float\n    snow_spectral_albedos: NDArray\n    snow_extinction_coefficients: NDArray\n\n    SSL_depth: float\n    SSL_spectral_albedos: NDArray\n    SSL_extinction_coefficients: NDArray\n\n    liquid_fraction: Optional[NDArray] = None\n\n    bands: ClassVar[List[Tuple[int, int]]] = WAVELENGTH_BANDS\n\n    def __post_init__(self):\n        # initialise liquid fraction as zero everywhere if not provided\n        if self.liquid_fraction is None:\n            self.liquid_fraction = np.full_like(self.z, 0)\n\n        # find the index of the ice ocean interface\n        self._ice_base_index = np.argmax(self.liquid_fraction &lt; 1)\n\n        # Generate band average ice absorption\n        UV_adjusted_bands = [(350, 400)] + self.bands[1:]  # Just average UV in 350-400\n        self.band_average_ice_absorption = np.array(\n            [\n                np.mean(\n                    calculate_ice_absorption_coefficient(\n                        np.linspace(band[0], band[1], 1000)\n                    )\n                )\n                for band in UV_adjusted_bands\n            ]\n        )\n        # Generate band average oil MAC\n        self.band_average_Romashkino_MAC = np.array(\n            [\n                np.mean(\n                    Romashkino_MAC(\n                        np.linspace(band[0], band[1], 1000),\n                        self.median_droplet_radius_in_microns,\n                    )\n                )\n                for band in UV_adjusted_bands\n            ]\n        )\n</code></pre>"},{"location":"#oilrad.six_band.model.solve_a_wavelength_band","title":"<code>solve_a_wavelength_band(model, wavelength_band_index)</code>","text":"<p>Use the scipy solve_bvp function to solve the two-stream model as a function of depth for each wavelength band.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>SixBandModel</code> <p>model parameters</p> required <code>wavelength_band_index</code> <code>int</code> <p>index of the wavelength band to solve</p> required <p>Returns:     tuple[NDArray, NDArray]: upwelling and downwelling irradiances as functions of depth Raises:     RuntimeError: if the solver does not converge</p> Source code in <code>oilrad/six_band/model.py</code> <pre><code>def solve_a_wavelength_band(\n    model: SixBandModel, wavelength_band_index: int\n) -&gt; tuple[NDArray, NDArray]:\n    \"\"\"Use the scipy solve_bvp function to solve the two-stream model as a function of\n    depth for each wavelength band.\n\n    Args:\n        model (SixBandModel): model parameters\n        wavelength_band_index (int): index of the wavelength band to solve\n    Returns:\n        tuple[NDArray, NDArray]: upwelling and downwelling irradiances as functions of depth\n    Raises:\n        RuntimeError: if the solver does not converge\n    \"\"\"\n    # Add radiaition absorbed in SSL into the top of the ice\n    if model.snow_depth == 0:\n        absorbed_in_SSL = (\n            1\n            - calculate_band_SSL_albedo(model, wavelength_band_index)\n            - calculate_band_surface_transmittance(model, wavelength_band_index)\n        )\n    else:\n        absorbed_in_SSL = 0\n\n    # In high wavelength band just assume all radiation is absorbed at ice surface\n    if wavelength_band_index == 5:\n        upwelling = np.zeros_like(model.z)\n        downwelling = np.zeros_like(model.z)\n        downwelling[-1] = (\n            calculate_band_surface_transmittance(model, 5) + absorbed_in_SSL\n        )\n        return upwelling, downwelling\n\n    fun = _get_ODE_fun(model, wavelength_band_index)\n    BCs = _get_BC_fun(model, wavelength_band_index)\n    solution = solve_bvp(\n        fun,\n        BCs,\n        np.linspace(model.z[0], model.z[-1], 5),\n        np.zeros((2, 5)),\n        max_nodes=12000,\n    )\n    if not solution.success:\n        raise RuntimeError(f\"{solution.message}\")\n\n    upwelling = solution.sol(model.z)[0]\n    downwelling = solution.sol(model.z)[1]\n    downwelling[-1] = downwelling[-1] + absorbed_in_SSL\n    return upwelling, downwelling\n</code></pre>"},{"location":"#oilrad.six_band.top_surface","title":"<code>top_surface</code>","text":"<p>Calculate surface transmittance for six band model through a snow layer and SSL</p>"},{"location":"#oilrad.solve","title":"<code>solve</code>","text":"<p>Provide a function to solve the two-stream model in the case of continuously varying optical properties which implements a faster solve approximation for long wavelengths if the fast_solve parameter of the model is set to True for the continuous wavelength case.</p>"},{"location":"#oilrad.solve.solve_two_stream_model","title":"<code>solve_two_stream_model(model)</code>","text":"<p>Solve the two-stream model and return an object containing the solution at all specified wavelengths</p> <p>Args (InfiniteLayerModel | SixBandModel):     model: two-stream model parameters</p> <p>Returns:</p> Type Description <code>CtsWavelengthSpectralIrradiance | SixBandSpectralIrradiance</code> <p>SpectralIrradiance | SixBandSpectralIrradiance: object containing the solution of the two-stream model at each wavelength</p> Source code in <code>oilrad/solve.py</code> <pre><code>def solve_two_stream_model(\n    model: CtsWavelengthModel | SixBandModel,\n) -&gt; CtsWavelengthSpectralIrradiance | SixBandSpectralIrradiance:\n    \"\"\"Solve the two-stream model and return an object containing the solution at all\n    specified wavelengths\n\n    Args (InfiniteLayerModel | SixBandModel):\n        model: two-stream model parameters\n\n    Returns:\n        SpectralIrradiance | SixBandSpectralIrradiance: object containing the solution of the two-stream model at each wavelength\n    \"\"\"\n\n    if isinstance(model, CtsWavelengthModel):\n        upwelling = np.empty((model.z.size, model.wavelengths.size))\n        downwelling = np.empty((model.z.size, model.wavelengths.size))\n        if model.fast_solve:\n            cut_off_index = (\n                np.argmin(np.abs(model.wavelengths - model.wavelength_cutoff)) + 1\n            )\n            is_surface = np.s_[cut_off_index:]\n            is_interior = np.s_[:cut_off_index]\n            for i, wavelength in enumerate(model.wavelengths[is_interior]):\n                col_upwelling, col_downwelling = solve_at_given_wavelength(\n                    model, wavelength\n                )\n                upwelling[:, i] = col_upwelling\n                downwelling[:, i] = col_downwelling\n\n            upwelling[:, is_surface] = 0\n            downwelling[:, is_surface] = 0\n            downwelling[-1, is_surface] = 1\n        else:\n            for i, wavelength in enumerate(model.wavelengths):\n                col_upwelling, col_downwelling = solve_at_given_wavelength(\n                    model, wavelength\n                )\n                upwelling[:, i] = col_upwelling\n                downwelling[:, i] = col_downwelling\n        return CtsWavelengthSpectralIrradiance(\n            model.z, model.wavelengths, upwelling, downwelling, model._ice_base_index\n        )\n\n    if isinstance(model, SixBandModel):\n        upwelling = np.empty((model.z.size, 6))\n        downwelling = np.empty((model.z.size, 6))\n        for index in WAVELENGTH_BAND_INDICES:\n            col_upwelling, col_downwelling = solve_a_wavelength_band(model, index)\n            upwelling[:, index] = col_upwelling\n            downwelling[:, index] = col_downwelling\n\n        ice_albedo = upwelling[-1, :]\n        surface_albedo = np.array(\n            [calculate_band_surface_albedo(model, i) for i in WAVELENGTH_BAND_INDICES]\n        )\n        surface_transmittance = np.array(\n            [\n                calculate_band_surface_transmittance(model, i)\n                for i in WAVELENGTH_BAND_INDICES\n            ]\n        )\n        albedo = surface_albedo + surface_transmittance * ice_albedo\n        return SixBandSpectralIrradiance(\n            model.z,\n            upwelling,\n            downwelling,\n            albedo,\n            model._ice_base_index,\n        )\n\n    raise NotImplementedError(\"Model type not recognized\")\n</code></pre>"},{"location":"#oilrad.spectra","title":"<code>spectra</code>","text":"<p>Module to provide the spectrum of incident downwelling shortwave radiation at the top of the domain.</p> <p>Currently only the black body spectrum is integrated which follows the solar spectrum at the top of the atmosphere, but is normalised to integrate to one in the shortwave range.</p> <p>Data used to compute the Planck function is from: https://www.oceanopticsbook.info/view/light-and-radiometry/level-2/light-from-the-sun</p>"},{"location":"#oilrad.spectra.BlackBodySpectrum","title":"<code>BlackBodySpectrum</code>  <code>dataclass</code>","text":"<p>Spectrum with blackbody shape that integrates to 1 between minimum and maximum wavelength specified in nm</p> <p>Once initialised the spectrum can be called with an array of wavelengths in nm.</p> <p>Parameters:</p> Name Type Description Default <code>min_wavelength</code> <code>float</code> <p>minimum wavelength in nm</p> required <code>max_wavelength</code> <code>float</code> <p>maximum wavelength in nm</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if wavelength is not in the shortwave range</p> Source code in <code>oilrad/spectra.py</code> <pre><code>@dataclass(frozen=True)\nclass BlackBodySpectrum:\n    \"\"\"Spectrum with blackbody shape that integrates to 1 between minimum and maximum\n    wavelength specified in nm\n\n    Once initialised the spectrum can be called with an array of wavelengths in nm.\n\n    Args:\n        min_wavelength: minimum wavelength in nm\n        max_wavelength: maximum wavelength in nm\n\n    Raises:\n        ValueError: if wavelength is not in the shortwave range\n    \"\"\"\n\n    min_wavelength: float\n    max_wavelength: float\n\n    @cached_property\n    def _total_irradiance(self) -&gt; float:\n        return quad(\n            self._top_of_atmosphere_irradiance, self.min_wavelength, self.max_wavelength\n        )[0]\n\n    @classmethod\n    def _top_of_atmosphere_irradiance(cls, wavelength_in_nm):\n        \"\"\"For wavelength in nm and temperature in K return top of atmosphere solar\n        irradiance in W/m2 nm\n        https://www.oceanopticsbook.info/view/light-and-radiometry/level-2/blackbody-radiation\n        \"\"\"\n        return (\n            _solar_planck_function(wavelength_in_nm * 1e-9, T=5782)\n            * (SUN_RADIUS**2 / AU**2)\n            * np.pi\n            * 1e-9\n        )\n\n    def __call__(self, wavelength_in_nm: NDArray) -&gt; NDArray:\n        if np.any(wavelength_in_nm &gt; self.max_wavelength) or np.any(\n            wavelength_in_nm &lt; self.min_wavelength\n        ):\n            raise ValueError(\n                f\"wavelength not in shortwave range {self.min_wavelength}nm - {self.max_wavelength}nm\"\n            )\n        return (\n            self._top_of_atmosphere_irradiance(wavelength_in_nm)\n            / self._total_irradiance\n        )\n</code></pre>"}]}